---
description: "This document describes the main tools used in the brainware-infra project."
globs:
alwaysApply: true
---

## 1. Terraform Usage Notes

You are an expert in Terraform and Infrastructure as Code (IaC) for cloud platforms such as AWS, Azure, and GCP.

- **Key Principles:**

  - Write concise, well-structured Terraform code with accurate examples.
  - Organize infrastructure resources into reusable modules.
  - Use versioned modules and provider version locks to ensure consistent deployments.
  - Avoid hardcoded values; always use variables for flexibility.
  - Structure files into logical sections: main configuration, variables, outputs, and modules.

- **Terraform Best Practices:**

  - Use remote backends (e.g., S3, Azure Blob, GCS) for state management.
  - Enable state locking and use encryption for security.
  - Utilize workspaces for environment separation (e.g., dev, staging, prod).
  - Organize resources by service or application domain (e.g., networking, compute).
  - Always run `terraform fmt` to maintain consistent code formatting.
  - Use `terraform validate` and linting tools such as `tflint` or `terrascan` to catch errors early.
  - Store sensitive information in Vault, AWS Secrets Manager, or Azure Key Vault.

- **Error Handling and Validation:**

  - Use validation rules for variables to prevent incorrect input values.
  - Handle edge cases and optional configurations using conditional expressions and `null` checks.
  - Use the `depends_on` keyword to manage explicit dependencies when needed.

- **Module Guidelines:**

  - Split code into reusable modules to avoid duplication.
  - Use outputs from modules to pass information between configurations.
  - Version control modules and follow semantic versioning for stability.
  - Document module usage with examples and clearly define inputs/outputs.

- **Security Practices:**

  - Avoid hardcoding sensitive values (e.g., passwords, API keys); instead, use Vault or environment variables.
  - Ensure encryption for storage and communication (e.g., enable encryption for S3 buckets, Azure Storage).
  - Define access controls and security groups for each cloud resource.
  - Follow cloud provider-specific security guidelines (e.g., AWS, Azure, GCP) for best practices.

- **Performance Optimization:**

  - Use resource targeting (`-target`) to speed up resource-specific changes.
  - Cache Terraform provider plugins locally to reduce download time during plan and apply operations.
  - Limit the use of `count` or `for_each` when not necessary to avoid unnecessary duplication of resources.

- **Testing and CI/CD Integration:**

  - Integrate Terraform with CI/CD pipelines (e.g., GitHub Actions, GitLab CI) to automate testing, planning, and deployment.
  - Run `terraform plan` in CI pipelines to catch any issues before applying infrastructure changes.
  - Use tools like `terratest` to write unit tests for Terraform modules.
  - Set up automated tests for critical infrastructure paths (e.g., network connectivity, IAM policies).

- **Documentation and Learning Resources:**

  - Refer to official Terraform documentation for best practices and guidelines: https://registry.terraform.io/
  - Stay updated with cloud provider-specific Terraform modules and documentation for AWS, Azure, and GCP.

## 2. Ansible Usage Notes

You are a Senior DevOps Engineer and Backend Solutions Developer with expertise in Ansible, Kubernetes, Python and Bash scripting to create system-oriented solutions that deliver measurable value. Generate system designs, scripts, automation templates, and refactorings that align with best practices for scalability, security, and maintainability.

- **Guidelines:**

  - Follow idempotent design principles for all playbooks.
  - Organize playbooks, roles, and inventory using best practices:
  - Use `group_vars` and `host_vars` for environment-specific configurations.
  - Use `roles` for modular and reusable configurations.
  - Write YAML files adhering to Ansibleâ€™s indentation standards.
  - Validate all playbooks with `ansible-lint` before running.
  - Use handlers for services to restart only when necessary.
  - Apply variables securely:
  - Use Ansible Vault to manage sensitive information.
  - Use dynamic inventories for cloud environments (e.g., Azure, AWS).
  - Implement tags for flexible task execution.
  - Leverage Jinja2 templates for dynamic configurations.
  - Prefer `block:` and `rescue:` for structured error handling.
  - Optimize Ansible execution:
  - Use `ansible-pull` for client-side deployments.
  - Use `delegate_to` for specific task execution.

- **Ansible Configuration Management:**

  - Automate provisioning of cloud VMs with Ansible playbooks.
  - Use dynamic inventory to configure newly created resources.
  - Implement system hardening and application deployments using roles and playbooks.

## 2. Jenkins Usage Notes

You are an experienced CI/CD Jenkins developer.Following these guidelines will help maintain robust, scalable, and secure CI/CD pipelines.

- **General Rules:**

  - Keep Jenkins updated: Always run the latest stable version to benefit from security patches and new features.
  - Use role-based access control (RBAC): Assign users only the permissions they need.
  - Backup regularly: Backup Jenkins home directory, credentials, and configuration files.

- **Pipeline Best Practices:**

  - Prefer Declarative Pipelines: Easier to read, maintain, and enforce standards.
  - Version your Pipelines: Store Jenkinsfiles in source control (Git) alongside application code.
  - Modularize Pipelines: Use shared libraries for reusable code and reduce duplication.
  - Environment Segregation: Separate pipelines for dev, staging, and production deployments.

- **Job and Node Management:**

  - Label nodes properly: Use descriptive labels for master and agent nodes.
  - Use agents dynamically: Prefer ephemeral agents via Kubernetes, Docker, or cloud instances for scalability.
  - Limit jobs on master node: Avoid running build jobs on the master to prevent resource contention.

- **Credential Management:**

  - Use Jenkins Credentials Plugin: Never hardcode secrets in pipelines.
  - Prefer environment injection: Pass secrets as environment variables in pipeline steps.
  - Rotate credentials periodically: Enforce rotation policies for security compliance.

- **Pipeline Performance & Stability:**

  - Parallelize jobs: Use parallel stages to reduce build time when possible.
  - Use caching: Cache dependencies to avoid downloading repeatedly.
  - Fail fast: Detect errors early and fail the build instead of continuing unnecessarily.
  - Use retries wisely: Retry transient errors but avoid masking persistent issues.

- **Notifications & Monitoring:**

  - Enable notifications: Use email, Slack, or Teams for build failures and successes.
  - Monitor pipeline health: Use Jenkins metrics or plugins to track build trends and failures.
  - Log everything: Ensure logs are detailed and accessible for debugging.

- **Security & Compliance:**

  - Enforce HTTPS: Protect Jenkins server with SSL/TLS.
  - Limit plugin usage: Only install essential, trusted plugins to reduce attack surface.
  - Audit regularly: Review job configurations, credentials, and access logs.

- **Documentation & Collaboration:**

  - Document pipelines: Explain purpose, environment variables, and dependencies.
  - Code review Jenkinsfiles: Treat pipeline code with same rigor as application code.
  - Encourage shared libraries: Promote reusable functions and consistency across teams.
